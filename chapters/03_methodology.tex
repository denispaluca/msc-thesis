% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Methodology / AlgoFuzz}\label{chapter:methodology}
Based on our research on Algorand smart contracts, we decided to develop a property-based fuzzer for Algorand.
As discussed in \ref{section:algorand-smartcontracts}, detecting errors that commonly happen in smart contracts can be better done by a static analyzer.
For this reason, we chose to go the same route as echidna and implement a subset of the features that are present in it. We named the newly developed fuzzing tool \textit{AlgoFuzz}.
In this chapter we discuss our general approach to fuzzing Algorand smart contracts and the implementation details of AlgoFuzz.

\section{Fuzzing Approach}
The first assumption that we made for our fuzzer is that the ABI of the smart contract is known and it follows the official conventions.
This is a reasonable assumption since the ABI is generated by the compiler and it is not expected to change between different versions of the compiler.
This provided us with the different functions that are available in the smart contract and the types of the arguments that they take.
From this information, comes the first part of the fuzzed input, the second part is the account that is used to call the smart contract.
Our fuzzing input would then be the following tuple: \texttt{(function, arguments, account)}.
To generate the inputs for our fuzzer we will be using a mutation-based approach.
Although Echidna is a grammar-based fuzzer, we decided to go with a mutation-based approach because it is easier to implement, more flexible, and it serves as a good starting point for future work.
For now, the inputs will be seeded with a random value, according to their type.
In the future, it would be interesting to have the user specify some valid seed values for the different arguments.
Our tool will initially not be supporting all argument types, from the ABI, but it will be supporting the most common ones.
The most important type left out will be:

\begin{itemize}
    \item \texttt{address}: This type is used to represent an address on the Algorand network.
          Giving random addresses in this case is not a good idea since the address is a 58 byte array that is encoded in base32.
          This means that the probability of generating a valid address is very low. For this reason, we decided to leave this type out of the initial implementation.
    \item \texttt{reference types}: Aside from the account reference type, all other reference types will not be supported since they are difficult to generate.
          For example, working with assets requires the user to opt-in to the asset as well as the application being fuzzed.
          Since this feature is not currently supported also generating an asset reference is not possible.
\end{itemize}

As mentioned before fuzzing consists of two parts the input generation and the input evaluation.
For the evaluation of the input, the user can define properties that should hold for the contract or they can run the fuzzing in \textit{Assertion Mode} which will check for all the possible assertion failures on application calls.
The properties that the user can define will be dependent on the state of the contract.
With the state the user can define arbitrary invariants which should always hold (return true).
Unfortunately due to limitations of the current version of Algorand nodes we will only be able to retrieve the global and local state of an application.
The methods that manipulate the box state of the application are currently not implemented for \texttt{dryrun} calls.
Dryrun calls are used to simulate the execution of a transaction without actually executing it.
They are important for our fuzzer since they allow us to retrieve the coverage information of an application call, which is used as a driver for the fuzzing process (discussed in \ref{section:drivers}).
Another limitation of our tool is that it expects opt-in calls to be empty.
In some Algorand contracts, opt-in calls may be connected to a certain function call that requires specific arguments.
Currently, it is not possible to infer from the ABI of the contract with which function an opt-in call is connected to.
Therefore, we decided to leave this feature out of the initial implementation and we opt in all required accounts with empty application calls.
Similarly to the opt-in calls, all other special calls are not executed by our tool.
The fuzzer only executes noop applications calls.

AlgoFuzz is implemented in Python and it uses the Python SDK for Algorand to interact with the Algorand network.
Working with the fuzzer requires the user to have a local Algorand network running in sandbox mode.
This can be extended in the future to make it possible fuzzing applications on the Algorand TestNet.


\section{Mutators} \label{section:mutators}
In this section we will go through the mutators and the heuristics that we implemented for our fuzzer.
A mutator has two important methods:
\begin{itemize}
    \item \texttt{mutate}: This method takes an input and mutates it.
          Internally, a mutator may have multiple mutation strategies that it uses to mutate the input.
    \item \texttt{seed}: This method seeds the input with a value.
          Currently, we have chosen simple initial values for all different types.
\end{itemize}

\subsection*{Boolean Mutator}
This mutator generates random boolean values. The values are all seeded with \texttt{False}.
The mutation strategy is simply to flip the value of the boolean.

\subsection*{Uint, Ufixed and Byte Mutators}
The Uint mutator generates random unsigned integer values. It is initialized with the size of the integer, from 8 to 256 bits. The seed value used is 0, since it is the smallest possible value and also a commonly used value. The mutation function chooses randomly from the following mutation strategies are used:
\begin{itemize}
    \item add - Adds a random value without overflowing.
    \item subtract - Subtracts a random value without underflowing.
    \item multiply - Multiplies the value with a random value without overflowing.
    \item divide - Divides the value with a random value without underflowing.
    \item random bit flip - Flips a random bit in the value.
    \item bitwise and - Performs a bitwise and with a random value.
    \item bitwise or - Performs a bitwise or with a random value.
    \item bitwise xor - Performs a bitwise xor with a random value.
\end{itemize}
The effectiveness of these strategies in fuzzing has been shown in previous works and we expect them to be effective in our case as well.

Ufixed and Byte mutators are special cases of the Uint mutator. The Ufixed mutator is initialized with the size of the integer part and the size of the fractional part. When mutating the value is first converted to an unsigned integer, mutated and then converted back to a fixed point number by dividing it with the fractional part size.

The Byte mutator is an alias for the Uint mutator with a size of 8 bits.

\subsection*{String, Array Dynamic and Array Static Mutators}
The String mutator and the dynamic length Array mutator work similarly. They are seeded with an empty string or array. Then one of the following mutation strategies is randomly chosen:
\begin{itemize}
    \item add - Adds a random value to the string or array at a random position.
    \item remove - Removes a random value to the string or array at a random position if the string or array is not empty.
    \item flip - Replaces a random value in the string or array with a random value.
\end{itemize}

The difference between the two that the array mutator also initializes a mutator for the type of the array.
This mutator is used to generate the random values to be added by mutating the seed or when flipping a value by mutating the value at the corresponding position.

The static length Array mutator is identical to the dynamic length Array mutator, except that it can only use the flip element mutation strategy.
Therefore, not changing the size of the array.

\subsection*{Tuple Mutator}

\subsection*{Account Mutator}

\subsection*{Payment Mutator}

\subsection*{Method Mutator}


\section{Scheduler}

\section{Partial and Total Fuzzing}
For most smart contracts, the code of different methods is relatively independent to each other.
Meaning the vast majority of methods are small, self-contained, and they rarely call common subroutines.
From this point of view each method of the contract can be seen as a separate program.
This means that we can fuzz each method separately and then combine the results.
We call this approach \textit{partial fuzzing} (similar to a partial derivative in math).
During fuzzing, the partial fuzzer creates only one application and a separate fuzzer for each method.
These \textit{method fuzzers} each have their own population of interesting inputs, power schedules, seeds, and other fuzzing parameters.
The population of inputs in this case being a list of tuples of the form \texttt{(arguments, account)}.
On each iteration the partial fuzzer randomly chooses a method and runs the corresponding method fuzzer.
All methods have the same probability of being chosen regardless of the amount interesting inputs are found for them.
Although this approach seems naive, it has been shown to be reasonably effective in practice from our experiments.
The main advantage of this approach is that it is very easy to implement and it generates new inputs faster.
The performance gain comes from the fact that the schedulers of the different method fuzzers have fewer inputs to choose from.
Another subtle advantage of the partial fuzzer is that methods which do not produce any interesting input during the seeding stage will not be completely ignored in the future fuzzing process.

The second approach that we implemented is \textit{total fuzzing}.
In this case, the fuzzer contains all necessary fuzzing parameters to fuzz the entire contract.
Different from the method fuzzers in the partial fuzzer, the population of inputs is a list of tuples of the form \texttt{(function, arguments, account)}.
This means that functions that produce more interesting inputs will be fuzzed more often which is the main advantage compared to the partial fuzzer.
The main disadvantage is that methods which do not produce any interesting input during the seeding stage will be consequently completely ignored.
To avoid this problem, we introduced a breakout mechanism through a coefficient passed to the constructor of the fuzzer.
This coefficient is used to determine the probability of uniformly randomly choosing one of the seeds and producing a new input by mutating it.
Since we create a seed for each function, there is a chance that the seed of a function that does not produce any interesting inputs is chosen.
We applied this breakout mechanism to the method fuzzers as well.



\section{Drivers}\label{section:drivers}

\section{Important Metrics}

\section{Case Study: AlgoTether}
