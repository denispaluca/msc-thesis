% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Methodology / AlgoFuzz}\label{chapter:methodology}
Based on our research on Algorand smart contracts, we decided to develop a property-based fuzzer for Algorand.
As discussed in \ref{section:algorand-smartcontracts}, detecting errors that commonly happen in smart contracts can be better done by a static analyzer.
For this reason, we chose to go the same route as echidna and implement a subset of the features that are present in it. We named the newly developed fuzzing tool \textit{AlgoFuzz}.
In this chapter we discuss our general approach to fuzzing Algorand smart contracts and the implementation details of AlgoFuzz.

\section{Fuzzing Approach}
The first assumption that we made for our fuzzer is that the ABI of the smart contract is known and it follows the official conventions.
This is a reasonable assumption since the ABI is generated by the compiler and it is not expected to change between different versions of the compiler.
This provided us with the different functions that are available in the smart contract and the types of the arguments that they take.
From this information, comes the first part of the fuzzed input, the second part is the account that is used to call the smart contract.
Our fuzzing input would then be the following tuple: \texttt{(function, arguments, account)}.
To generate the inputs for our fuzzer we will be using a mutation-based approach.
Although Echidna is a grammar-based fuzzer, we decided to go with a mutation-based approach because it is easier to implement, more flexible, and it serves as a good starting point for future work.
For now, the inputs will be seeded with a random value, according to their type.
In the future, it would be interesting to have the user specify some valid seed values for the different arguments.
Our tool will initially not be supporting all argument types, from the ABI, but it will be supporting the most common ones.
The most important type left out will be:

\begin{itemize}
    \item \texttt{address}: This type is used to represent an address on the Algorand network.
          Giving random addresses in this case is not a good idea since the address is a 58 byte array that is encoded in base32.
          This means that the probability of generating a valid address is very low. For this reason, we decided to leave this type out of the initial implementation.
    \item \texttt{reference types}: Aside from the account reference type, all other reference types will not be supported since they are difficult to generate.
          For example, working with assets requires the user to opt-in to the asset as well as the application being fuzzed.
          Since this feature is not currently supported also generating an asset reference is not possible.
\end{itemize}

As mentioned before fuzzing consists of two parts the input generation and the input evaluation.
For the evaluation of the input, the user can define properties that should hold for the contract or they can run the fuzzing in \textit{Assertion Mode} which will check for all the possible assertion failures on application calls.
The properties that the user can define will be dependent on the state of the contract.
With the state the user can define arbitrary invariants which should always hold (return true).
Unfortunately due to limitations of the current version of Algorand nodes we will only be able to retrieve the global and local state of an application.
The methods that manipulate the box state of the application are currently not implemented for \texttt{dryrun} calls.
Dryrun calls are used to simulate the execution of a transaction without actually executing it.
They are important for our fuzzer since they allow us to retrieve the coverage information of an application call, which is used as a driver for the fuzzing process (discussed in \ref{section:drivers}).
Another limitation of our tool is that it expects opt-in calls to be empty.
In some Algorand contracts, opt-in calls may be connected to a certain function call that requires specific arguments.
Currently, it is not possible to infer from the ABI of the contract with which function an opt-in call is connected to.
Therefore, we decided to leave this feature out of the initial implementation and we opt in all required accounts with empty application calls.
Similarly to the opt-in calls, all other special calls are not executed by our tool.
The fuzzer only executes noop applications calls.

AlgoFuzz is implemented in Python and it uses the Python SDK for Algorand to interact with the Algorand network.
Working with the fuzzer requires the user to have a local Algorand network running in sandbox mode.
This can be extended in the future to make it possible fuzzing applications on the Algorand TestNet.


\section{Mutators} \label{section:mutators}
In this section we will go through the mutators and the heuristics that we implemented for our fuzzer.
A mutator has two important methods:
\begin{itemize}
    \item \texttt{mutate}: This method takes an input and mutates it.
          Internally, a mutator may have multiple mutation strategies that it uses to mutate the input.
    \item \texttt{seed}: This method seeds the input with a value.
          Currently, we have chosen simple initial values for all different types.
\end{itemize}

\subsection*{Boolean Mutator}
This mutator generates random boolean values. The values are all seeded with \texttt{False}.
The mutation strategy is simply to flip the value of the boolean.

\subsection*{Uint, Ufixed and Byte Mutators}


\subsection*{String, Array Dynamic and Array Static Mutators}

\subsection*{Tuple Mutator}

\subsection*{Account Mutator}

\subsection*{Payment Mutator}

\subsection*{Method Mutator}


\section{Scheduler}

\section{Partial and Total Fuzzing}

\section{Drivers}\label{section:drivers}

\section{Important Metrics}

\section{Case Study: AlgoTether}
