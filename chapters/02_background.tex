% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Background and Related Work}\label{chapter:background}
This chapter introduces the technical background and related work for the thesis. It establishes the foundation for the thesis by introducing the concepts of blockchain, smart contracts and specifically smart contracts on the Algorand blockchain network. Furthermore, challenges related to smart contract security and testing are explored, underlining the importance of fuzzing as a relatively novel testing tool in the space. Existing projects in the field of smart contract fuzzing are examined, with the focus on deriving evaluation methods for our own fuzzer.

\section{Blockchain}
Bitcoin was first introduced in 2008 by an anonymous person or group of people under the name of Satoshi Nakamoto \cite{nakamoto_bitcoin_2008}. The purpose of the project was to facilitate online payments without them having to go through a financial institution. Previous solutions were hindered by the double-spend problem, where a user can counterfeit the currency if there isn't a trusted central authority keeping track of the different transactions and the balances. Bitcoin solved this problem with a peer-to-peer network. In this network the nodes keep track of all the transactions that have been committed in a public ledger. These transactions are added to into block which are then chained together through cryptographic hashes. The nodes in the network keep track of the longest chain of blocks and accept the longest chain as the valid one. This is called the \textit{proof-of-work} consensus mechanism. The nodes in the network are incentivized to keep the network secure by receiving a reward in the form of newly minted bitcoins for every block they add to the chain. This process is called \textit{mining}. The proof-of-work consensus is computationally expensive, which makes it difficult for an attacker to create a longer chain than the honest nodes. The attacker would have to have more computational power than the rest of the network combined. This is called the 51\% attack. The Bitcoin network has been running for over 10 years and has never been compromised. The Bitcoin network has several limitations, such as the low transaction throughput and the high energy consumption of the proof-of-work consensus mechanism. These limitations have led to the development of new blockchain networks with different consensus mechanisms.

Another interesting feature of Bitcoin that does not have much notoriety is Bitcoin Script. Bitcoin Script is a simple stack-based programming language that is used to define the conditions under which a transaction can be spent. The execution of the script is successful if the stack is empty and failed otherwise. The Bitcoin Script is not Turing-complete, which means that it cannot be used to implement arbitrary programs. Bitcoin Script was not intended to be used for more complex scripts, but it did inspire the creation of new networks that would allow for more complex scripts, later called smart contracts.

\section{Smart Contracts}
The term "Smart Contract" was first coined by Szabo in 1996, to refer to promises between parties and the protocols to perform on these promises stored in digital form \cite{szabo_smart_1996}. This concept was then first connected with blockchain through Ethereum which was proposed by Buterin in 2014 \cite{buterin_ethereum_2014}. Similar to Bitcoin, at the time of its conception Ethereum was also running on a proof-of-work consensus, and it had its own currency named Ether. Ethereum went on to expand on the concept of Bitcoin Scripts by allowing arbitrary Turing-complete code to be run on its network. This allowed for the creation of more complex smart contracts, similar to what Szabo had described earlier. Since the Ethereum network is completely permissionless (meaning anyone can participate without explicit permission from an authority), the addition of smart contracts transformed this network into a world computer.

The model of the Ethereum smart contracts is pretty simple and since Ethereum was the first blockchain network that supported smart contracts many succeeding networks are more or less similar. For this reason, it is interesting to mention how Ethereum smart contracts work and later to mention how Algorand Smart Contracts differ. Each smart contract has its state (the data of the contract), functions (the code of the contract) and an Ethereum account connected to this contract. The state of the contract is stored in the Ethereum blockchain and is accessible to anyone. The account of the contract is not controlled by a user but only by the code of the corresponding contract. The functions of the contract are the code that is executed when the contract is called. These functions have access not only to the state of the contract, but also to the state of the blockchain. This means that the functions can read the state of other contracts and even call their functions. Also, the function has access to the address of the call and the amount of ether that the call may have sent. When a function is called, it is executed by all the nodes in the network. This means that the function is executed in a deterministic way and the result is the same for all the nodes. Because of this, the execution of the function can be expensive for the nodes. Therefore, the caller of the function has to pay a fee for the execution. This fee is calculated based on the amount of computational resources that the function consumes. This means that the more complex the function is, the more expensive it is to execute. The fee is paid in ether and is collected by the nodes that execute the function as an incentive. The fee is also used to prevent denial-of-service attacks, where a malicious user would try to execute a function that consumes a lot of resources and thus make the network unusable.

Allowing anyone to deploy and run arbitrary code on the network has led to the creation of a large ecosystem of decentralized applications (dApps). These dApps are similar to traditional web applications, but they are not controlled by a single entity. Instead, they are controlled by the code that is deployed on the network. This means that the code is immutable and cannot be changed once it is deployed. This is a double-edged sword, as it means that the code cannot be changed if there is a bug or a security vulnerability. Usually smart contracts control large sums of digital currencies or digital assets, which makes them a very attractive target for attackers. For this two reasons combined, it is of utmost importance to ensure the security of the smart contract before they are deployed.


\section{Smart Contract Security}
As we already laid out the importance of smart contract security, we will now explore the different types of vulnerabilities that can be found in smart contracts. Keeping smart contracts secure is compromised of two parts: writing vulnerability free smart contract code and also insuring that the administrating account of the smart contract is managed safely off-chain. We will be focusing on the first part.

Smart contracts have a lot of idiosyncrasies that set them apart from usual computer programs. Therefore, the types of vulnerabilities that we face when developing smart contracts are usually specific to the world of blockchain and more precisely they differ from one blockchain network to the other. The following list is a non-exhaustive list of vulnerabilities that can be found in smart contracts:
\begin{itemize}
    \item \textbf{Reentrancy} - Although this vulnerability is specific to the Ethereum network, it is worth mentioning since it is one of the most iconic blockchain vulnerabilities. It is caused by the fact that the execution of a function is not atomic. This means that the execution of a function can be interrupted by another function call. This can lead to a vulnerability where a malicious user can call the same function multiple times before the first execution is finished. In this manner, the malicious user could be able to drain the funds of the contract.
    \item \textbf{Integer Overflow and Underflow} - This vulnerability is not specific to smart contracts, but it is more prevalent in smart contracts due to the fact that most networks use fixed-size integers. This means that the maximum value of an integer is usually 2\textsuperscript{256}-1. If the result of an operation on integers is larger than the maximum value, the result will overflow and the integer will wrap around to 0. This can lead to a vulnerability where a malicious user can overflow the balance of the contract and drain all the funds.
    \item \textbf{Timestamp Dependence} - This vulnerability is also not specific to smart contracts, but it is more prevalent in smart contracts due to the fact that the most networks has a timestamp variable. This variable can be manipulated by the miner that mines the block that contains the transaction. This can lead to a vulnerability where a malicious user can call a function at a specific time to exploit the contract.
    \item \textbf{Front-running} - This vulnerability is specific to smart contracts. It is caused by the fact that the order of transactions is not deterministic. This means that a malicious user can submit a transaction that is executed before another transaction that was submitted earlier. This can lead to a vulnerability where a malicious user can exploit a contract by submitting a transaction that is executed before a transaction that was meant to prevent the exploit. After Ethereum transitioned to proof-of-state, the vulnerability still persists since the block proposer can choose which transactions to include and their order in the block.
    \item \textbf{Resource Limit Vulnerabilities} - As already mentioned above the execution of a function in most blockchain will incur a cost on the caller. This cost is calculated based on the amount of computational resources that the function consumes. This means that the more complex the function is, the more expensive it is to execute. If the function is too complex, the costs of executing it might exceed certain limitations of the network or the funds of the contract. This can lead to certain functions of the contract being unusable after a while. An example of this would be calling a function that pays out funds to users from a large array. If the users in the array are too many, the function might not be able to pay out all the users due to the cost of the function exceeding the funds of the contract.
    \item \textbf{Simple Logical Errors} - Although most smart contract are thoroughly scrutinized by the community, still a significant number of vulnerabilities are caused by simple logical errors. These errors cannot be simply avoided by adding features to your blockchain, as they are inherent in all computer programs written by humans.
\end{itemize}

To deal with these vulnerabilities different tools have been proposed such as static analysis tools, symbolic execution tools and fuzzers, while we will discuss more of on section \ref{section:fuzzing}.

In the next section we will explore the Algorand blockchain network, its smart contracts, how it handles the previously mentioned vulnerabilities and which vulnerabilities are specific to it.

\section{Algorand}
Algorand was initially proposed in 2017 by Chen et al. \cite{chen_algorand_2017}. It sought to improve on previous networks by solving the scalability trilemma, which states that a blockchain network can only have two of the following three properties: security, scalability and decentralization. This is due to the fact that previous networks relied on a consensus mechanism that was computationally expensive and thus limited the transaction throughput of the network. Algorand solved this problem by introducing a new consensus mechanism called \textit{pure proof-of-stake}. This consensus mechanism has the advantage of being computationally inexpensive and thus allows the network to scale. The network is permissionless, which means that anyone can participate in the consensus and thus the network is decentralized. The consensus mechanism is also byzantine fault tolerant, which means that it can tolerate up to 1/3 of the nodes in the network being malicious. This means that the network can still function even if up to 1/3 of the nodes in the network are malicious. According to the authors, the possibility of a fork in the network is 10\textsuperscript{-18}, meaning the network achieves instant finality of a transaction, from the moment it enters the ledger. Different from Bitcoin where the finality of a transaction is probabilistic and it increases as more blocks are added to the chain. For Bitcoin finality is usually reached after 6 confirmations (meaning 6 blocks after the one containing the interesting transaction). At the time of this writing, new blocks are produced at an average of 3.5 seconds and can hold up to 25000 transactions, which results in a transaction throughput of 7150 transactions per second (TPS).

The native currency of the Algorand network is called Algo, and it has a maximum supply of 10 Billion Algos. The smallest unit of Algo is called a microAlgo and it is equal to 0.000001 Algo. The Algo is used to pay the transaction fees of the network and also to participate in the consensus. Different from the Ethereum gas fee, Algorand fees are only paid if the transaction is included in a block. Transaction fees are calculated based on congestion of the network, but because of the high TPS most transactions can use the minimum base fee of 0.001 Algos. In addition to the fees, Algorand has also minimum balance requirements (MBR) for its accounts. The MBR acts as a deposit to rent space on the blockchain. Every time the amount of stored date on the blockchain increases, the MBR of the associated account also increases. When the space is liberated by deleting data, the MBR is also decreased. All accounts have a base MBR of 0.1 Algo.

A powerful feature of the protocol is the ability to rekey an account. What this means is being able to change the authoritative spending private key of an account. This is really useful in cases where the user wants to maintain a static public address but wants his private key rotated for security reasons.

Different from other networks, the ability to create fungible and non-fungible tokens is directly built into the protocol. These tokens are created using Algorand Standard Assets (ASA) and a special transaction type is required when creating them. On other blockchains a smart contract is required to represent these tokens. Similarly, in Algorand you could have a smart contract to create and control the tokens, but it is not mandatory.

Smart signatures are another feature of the Algorand network, which should not be confused with smart contracts. They are similar to the Bitcoin Scripts. They contain logic that is used to sign a transaction. This logic is then submitted together with the transaction. The logic is then executed by the nodes in the network and if the execution is successful, the transaction is signed and submitted to the network.

\subsection*{Algorand Smart Contracts}


\section{Fuzzing} \label{section:fuzzing}

\section{Related Work}
